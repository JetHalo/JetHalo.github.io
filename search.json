[{"categories":null,"content":"\nWhom will I give the key to? Long, long ago, there was an old croesus who sold carpets, locally known as “Ala-kiyiz,” on the Silk Road. Due to his superb skills, his “Ala-kiyiz” became the most famous good on the Silk Road, and every passing businessman would buy his carpet. Year after year, he became the richest man in Bishkek.\nThe croesus earned a huge amount of money and built a castle, which was very sturdy that nobody could enter it, and nobody could destroy the castle. All of his gold was stored in it. He was a good man, very generous, and helped a lot of poor people. However, he was advanced in age and burdened with worries.\nWhat was he worried about? Actually, he was worried about his gold. If he was too old to move, how could he manage his property? The croesus had five sons named Greed, Hatred, Stupidity, Nirvana, and Karma. Each of them had their weakness, but he didn’t want to see the contradiction between his sons. He didn’t want one of his sons to have the only key to the castle because someday the son who has the only key might take all of the money without the other sons knowing about this situation.\nSo, “Whom will I give the key to?” He was confused a lot. So he asked for Afanti’s help. Two months later, Afanti came to the croesus’s home again and gave a lock to the croesus. Then he showed the lock and said,\n“I will give you six keys, and each tree of these keys can open the lock of the castle together.”\nSo every time they needed to get into the castle, they needed at least any three keys of these six keys together. Only this method could open the castle’s door.\nThe croesus was very happy and gave Afanti a lot of money. Afanti smiled and shared all of that money with poor people.\nWhat is Shamir’s Secret Sharing?\nI think you have just read the story above. You must have encountered a similar situation in your daily life, especially if you want somebody to take care of your keywords or passwords, which are very important to you. Here is an interesting “real-world” example of this situation: According to Time Magazine, control of nuclear weapons in Russia in the early 1990s depended upon a similar “two-out-of-three” access mechanism. The three parties involved were the President, the Defense Minister, and the Defense Ministry.\nSo, what is Shamir’s Secret Sharing?\nAlgorithm definiton Shamir’s Secret Sharing is an algorithm in cryptography created by Adi Shamir. It is a form of secret sharing where a secret is divided into parts, giving each participant their unique part. To reconstruct the original secret, a minimum number of parts is required. In the threshold scheme, this number is less than the total number of parts. Otherwise, all participants are needed to reconstruct the original secret.\nWe will first study a special type of secret sharing scheme called a threshold scheme.\nHere is an informal definition.\nDefinition:\nLet $t,w$ positive integers,$t\\leq w$.A ($t,w$)-threshold scheme is method of sharing a key K among a set of w participants(denoted by $\\rho$) , in such a way that any $t$ participants can compute the value of $K$,but no group of $t-1$ participants can do so .\nAlright, I think you already understand the concept of Shamir’s Secret Sharing. Now you may be wondering, “Yeah, I know the concept. It’s quite simple, but could you tell me how to implement this algorithm and how to verify its correctness?”\nSplitting the key into shares According to the definition of Shamir’s Secret Sharing, we assume we have a secret and we want to split it into parts. How can we do that? The method below will explain how to split the secret.\nShamir($t,w$)-Threshold Scheme\nInitialization Phase\n1.$D$ chooses $w$ distinct, non-zero elements of $Z_p$,denoted $x_i$,$1\\leq i\\leq w$（this is where we require $p\\geq w+1$. For $1\\leq i\\leq w$ ,$D$ gives the value $x_i$ to $P_i$.The values $x_i$ are public.\nShare Distribution\n2.Suppose $D$ wants to share a key $K\\in Z_p$. $D$ secretly chooses(independently at random)$t-1$ elements of $Z_p$, which are denoted $a_1,….a_{t-1}$.\n3.For $1\\leq i\\leq w$ , $D$ computes $y_i=a(x_i)$, where $$a(x)=K+\\sum_{j=1}^{t-1}a_jx^jmodp$$\n4.For $1\\leq i\\leq w$ , $D$ gives the share $y_i$ to $P_i$.\nIt suggests that we construct a polynomial which contains the highest degree of $t-1$ and has random coefficients. Finally, the intercept of the polynomial is the key. So, $a(x)$ represents the shares we just split.\nNow that you know how to split the key into shares, you might be wondering what it all means! Why does $a(x)$ represent the shares? And what is the meaning of “mod”?\nDon’t worry! Listen to me for a moment. Let’s walk through the example below together, and then I will explain the mathematical tools you need to know.\nexample: hole progress split and reconstruction Preparation Suppose that our secret is 1234 $(S=1234)$.\nWe wish to divide the secret into 6 parts $(w=6)$, where any subset of 3 parts $(t=3)$is sufficient to reconstruct the secret. At random we obtain $k-1$ numbers: 166 and 94.\n$(a_0=1234;a_1=166;a_2=94)$, where $a_0$ is secret\nOur polynomial to produce secret shares (points) is therefore: $a(x)=1234+166x+94x^2$\nWe construct six points$D_{x-1}=(x, f(x))$ from the polynomial:\n$D_0=(1, 1494);D_1=(2, 1942);D_2=(3, 2578); $\n$D_3=(4, 3402); D_4= (5, 4414);D_5=(6, 5614),$\nWe give each participant a different single point (both$x$ and $a(x)$. Because we use $D_{x+1}$ instead of $D_x$ the points start from $(1, a(1))$and not$(0, a(0))$. This is necessary because $a(0)$ is the secret.\nReconstruction In order to reconstruct the secret any 3 points will be enough.\nConsider $\\left(x_0,y_0\\right)=\\left(2,1942\\right);\\left(x_1,y_1\\right)=\\left(4,3402\\right);\\left(x_2,y_2\\right)=\\left(5,4414\\right),$.\nWe will compute Lagrange basis polynomials:\n$\\ell_0=\\frac{x-x_1}{x_0-x_1}\\cdot\\frac{x-x_2}{x_0-x_2}=\\frac{x-4}{2-4}\\cdot\\frac{x-5}{2-5}=\\frac{1}{6}x^2-\\frac{3}{2}x+\\frac{10}{3},$\n$\\ell_1=\\frac{x-x_0}{x_1-x_0}\\cdot\\frac{x-x_2}{x_1-x_2}=\\frac{x-2}{4-2}\\cdot\\frac{x-5}{4-5}=-\\frac{1}{2}x^2+\\frac{7}{2}x-5,$\n$\\ell_2=\\frac{x-x_0}{x_2-x_0}\\cdot\\frac{x-x_1}{x_2-x_1}=\\frac{x-2}{5-2}\\cdot\\frac{x-4}{5-4}=\\frac{1}{3}x^2-2x+\\frac{8}{3},$\nTherefore\n$ a(x) =\\sum_{j=0}^2 y_j\\cdot\\ell_j(x) $\n$=y_0\\ell_0+y_1\\ell_1+y_2\\ell_2 $\n$=1942\\left(\\frac{1}{6}x^2-\\frac{3}{2}x+\\frac{10}{3}\\right) + 3402\\left(-\\frac{1}{2}x^2+\\frac{7}{2}x-5\\right) + 4414\\left(\\frac{1}{3}x^2-2x+\\frac{8}{3}\\right)$\n$=1234+166x+94x^2$\nwow~ you have just get the secret (The key) from the shares which generate by the method.\nRecall that the secret is the free coefficient, which means that $S=1234,$, and we are done.\nBut wait, I haven’t answered the question about “mod” yet. How does it work? Also, what are the Lagrange basis polynomials?\nDon’t worry, let’s dive into these concepts in the next chapter.\nsome useful mathematical tool In this chapter I will tell you tree concept Galois Field，lagrange interpolation，and polynomial.\ngalois field Évariste Galois was a radical republican and a romantic figure in French mathematical history. He died in a duel at the young age of 20, but the work he published shortly before his death made his name in mathematical circles and allowed later mathematicians to prove problems that had been unsolvable for many centuries. It also laid the groundwork for many later developments in mathematics, particularly in the important fields of abstract algebra and group theory.\nWhat is a field? Graphically speaking, a field has the property that it is closed under addition and multiplication. In other words, the result of adding or multiplying the elements in the field is still an element in the field. It should be noted that the addition and multiplication in a field may not necessarily be the same as the addition and multiplication we typically use.\nA field has two concepts of an identity element and an inverse element. There are corresponding identity elements for addition and multiplication operations, with both represented by the symbol $e$. The identity element is like the identity matrix in linear algebra, where a matrix multiplied by the identity matrix is equal to itself. Correspondingly, the unit elements in the field are as follows: for the addition identity element, all elements plus the identity element $e$ are equal to itself. For the multiplication identity element, all elements multiplied by the identity element $e$ are equal to itself.\nInverse elements are like mathematical inverses. Two elements are each other’s inverse element. If elements $a$ and $b$ are additive inverses, then $a + b = e$. If they are multiplicative inverses, then $a * b = e$. If an element $a$ cannot find another element $b$ in the domain such that $a + b = e (a * b = e)$, then $a$ has no addition (multiplication) inverse.\nThe use of inverse elements is for division operations. In school, teachers will teach us that dividing a fraction is equal to multiplying the inverse of the fraction. So if you want to divide by a number, you can multiply the inverse of that number.\nA set has addition identity elements and multiplication identity elements, and each element has an additive inverse element and a multiplicative inverse element, which are necessary conditions for becoming a field. It should be noted that even if the set has element 0 and 0 has no corresponding multiplicative inverse, then the set may still be a field because it does not require zero to have a multiplicative inverse.\nAn example of a field is the set of rational numbers that we are familiar with. The corresponding additions and multiplications are the additions and multiplications we usually use. Among them, the identity element of the addition is 0, and the addition inverse of the rational number $a$ is the opposite number because $a + (-a) = 0$. The identity element of multiplication is 1, and the multiplication inverse of $a$ is its inverse because $a * (1 / a) = 1$. Note that element 0 here does not have a multiplicative inverse.\nwhat is galois field In cryptography theory, the finite field GF($p$) is an important field, where $p$ is a prime number. In simple terms, GF($p$) is mod $p$, because after a number modulo $p$, the result is between [0, $p$-1]. For elements $a$ and $b$, then $(a + b)$ mod $p$ and $(a * b)$ mod $p$, the results are all elements in the field. The addition and multiplication in GF($p$) are the usual additions and multiplications. The addition and multiplication identity elements of GF($p$) are 0 and 1 respectively.\nAnd now we answer the question before, what is the meaning of mod $p$? It means some number divided by $p$ and the remainder is what the mod $p$ represents. We do this to make sure that all of these numbers are in the field.\nIf $p$ is prime, then it can guarantee that all elements in the field have inverses. That is, for any element $a$ in the field, another element $b$ can always be found in the field, so that $a * b$ mod $p$ is equal to 1.\nWhat is GF($2^8$)? As mentioned earlier, GF($p$), $p$ must be a prime number to ensure that all elements in the set have addition and multiplication inverses (except 0). But we really hope that 256 numbers from 0 to 255 can also form a field, because many fields need to be used. The remainder of mod 256 ranges from 0 to 255, but 256 is not a prime.\nIt is very frustrating that we cannot use GF(256). How can we deal with it? Actually, we can use GF($2^n$).\nTo understand GF($2^n$), you must first understand polynomial operations. There are some differences between polynomials here and junior high school polynomial operations, although their representations are the same. Here are some of its features.\nThe coefficients of the polynomial can only be 0 or 1. Of course, for GF($p^n$), if $p$ is equal to 3, then the coefficient can be taken as: (0, 1, 2). When merging similar terms, the coefficients use XOR operation instead of the usual addition operation. For example, $x^4 + x^4$ is equal to $0 * x^4$. Because both coefficients are 1, the result will be equal to 0 after XOR operation. It doesn’t matter with subtraction and negative coefficients (subtraction is equal to addition) or negative coefficients. Therefore, $x^4 - x^4$ is equal to $x^4 + x^4$. $-x^3$ is $x^3$. $GF(2^3) = (0, 1, x, x + 1, x^2, x^2 + 1, x^2 + 2, x^2 +x + 1)$ $= (0, 1, 2, 2 + 1, 2^2, 2^2 + 1, 2^2 + 2, 2^2 + 2 + 1)$\n$= (0, 1, 2, 3, 4, 5, 6, 7)$\nwhich consists of 2^3 = 8 elements where each of them is a polynomial of degree at most 2 evaluated at 2.\nPolynomials in Galois Field are similar to integers and have prime polynomials, which are defined similarly to prime numbers. Prime polynomials cannot be expressed as the product of two other polynomials.\nThe Galois Field is particularly useful for translating computer data, as it is represented in binary form consisting of the two numbers, 0 and 1, which are the components in Galois field whose number of elements is two. Representing data as a vector in a Galois Field allows mathematical operations to scramble data easily and effectively.\nFor $GF(2^8)$, one of the prime polynomials is $x^8 + x^4 + x^3 + x + 1$. There are correspondingly 256 polynomials of less than 8 degrees.\nWe will now implement this Galois Field in Rust.\nThe following code mainly generates polynomials with the prime polynomial $x^8 + x^4 + x^3 + x + 1$.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 use subtle::{Choice, ConditionallySelectable, ConstantTimeEq}; use std::ops::{Add, AddAssign, Div, DivAssign, Mul, MulAssign, Neg, Sub, SubAssign}; pub struct GF256(pub u8); impl GF256 { pub fn pow(self, elem: u8) -\u003e Self { let mut res = GF256::one(); for i in 0..8 { res.square(); let mut tmp = res; tmp.mul_assign(self); res.conditional_assign(\u0026tmp, (((elem \u003e\u003e i) \u0026 0x01) as u8).into()); } res.conditional_assign(\u0026GF256::one(),(elem.ct_eq(\u00260)).into()); res } } impl MulAssign for GF256 { fn mul_assign(\u0026mut self, rhs: GF256) { let a = self.0; let mut b = rhs.0; // let mut t: u8; self.0 = 0x00; for i in 0..8 { let lsb_of_a_not_0 = !(((a \u003e\u003e i) \u0026 0x01).ct_eq(\u00260x00)); self.conditional_assign(\u0026GF256(self.0 ^ b), lsb_of_a_not_0); let choice = (b \u0026 0x80).ct_eq(\u00260x00); b \u003c\u003c= 1; let tmp = b ^ 0x1b; b.conditional_assign(\u0026tmp, !choice); } } } Implment the Field for $GF(2^8)$\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 impl Field for GF256 { /// Returns the zero element of the field (additive identity) fn zero() -\u003e Self { GF256(0) } /// Returns the zero element of the field (multiplicative identity) fn one() -\u003e Self { GF256(1) } /// Returns true if this element is the additive identity fn is_zero(\u0026self) -\u003e bool { self.0.ct_eq(\u00260).into() } /// Squares the element fn square(\u0026mut self) { self.mul_assign(*self); } /// Returns multiplicative inverse (self^254) fn inverse(\u0026self) -\u003e Option\u003cSelf\u003e { let mut res = *self; for _ in 0..6 { res.square(); res.mul_assign(*self); } res.square(); res.conditional_assign(\u0026GF256::zero(), self.0.ct_eq(\u00260x00)); Some(res) } } lagrange interpolation This chapter discusses why we can reconstruct the key from the K-1 degree polynomials, where\nk points can determine a curve of k-1 degree.\nTo understand this, let us look at how Lagrange interpolation is derived.\nAssume that we have a set of points and we want to find a curve that passes through them. Consider the following set of points: We want to determine the equation of the curve that passes through these points.\nLagrange believed that this could be achieved by adding three quadratic curves. But what do these three quadratic curves look like?\nThe first curve $f_1(x)$, at the $x_1$ point, the value is 1 and the remaining two points are 0:\nThe second curve $f_2(x)$, at the $x_2$ point, the value is 1 and the remaining two points are 0:\nThe third curve $f_3(x)$, at the $x_3$ point, the value is 1 and the remaining two points are 0: $y_1f_1(x)$can guarantee that at the $x_1$ point, the value is $y_1$ and the other two points are set to 0. $y_2f_2(x)$can guarantee that at the $x_2$ point, the value is $y_2$ and the other two points are set to 0. $y_3f_3(x)$can guarantee that at the $x_3$ point, the value is $y_3$ and the other two points are set to 0. So $$f(x)=y_1f_1(x)+y_2f_2(x)+y_3f_3(x) $$\nlet us the the picture show us below:\nWhat an amazing thought !!!\nDefinition\nGiven a set of $k+1$ data points\n$(x_0, y_0),\\ldots,(x_j, y_j),\\ldots,(x_k, y_k)$\nwhere no two $x_j$ are the same, the interpolation polynomial in the Lagrange form is a linear combination.\n$$L(x) = \\sum_{j=0}^{k} y_j \\ell_j(x)$$ of Lagrange basis polynomials $\\ell_j(x) = \\prod_{\\begin{smallmatrix}0\\le m\\le k \\ m\\neq j\\end{smallmatrix}} \\frac{x-x_m}{x_j-x_m} = \\frac{(x-x_0)}{(x_j-x_0)} \\cdots \\frac{(x-x_{j-1})}{(x_j-x_{j-1})} \\frac{(x-x_{j+1})}{(x_j-x_{j+1})} \\cdots \\frac{(x-x_k)}{(x_j-x_k)},$ where $0\\le j\\le k$.\nHence we have the Lagrange interpolation formula:\n$$p(x) = \\sum_{j=1}^{n} y_j \\ell_j(x)$$\nWe can modify this form into Barycentric Form：\nUsing\n$\\ell(x) = (x - x_0)(x - x_1) \\cdots (x - x_k)$\nwe can rewrite the Lagrange basis polynomials as $\\ell_j(x) = \\ell(x)\\frac{w_j}{x-x_j}$\nThe advantage of this representation is that the interpolation polynomial may now be evaluated as\n$p(x) = \\ell(x) \\sum_{j=0}^k \\frac{w_j}{x-x_j}y_j$\nNote that in the case $y_1$ = ··· = $y_n$ = 1 the interpolating polynomial must be p(x) = 1, hence\n$$p(x) = \\frac{\\sum_{j=0}^k \\frac{w_j}{x-x_j}y_j}{\\sum_{j=0}^k \\frac{w_j}{x-x_j}}$$\nThe algrithm is following :\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 pub fn barycentric_interpolate\u003cFq: Field\u003e(points: \u0026[(Fq, Fq)]) -\u003e Fq { let mut result = Fq::zero(); let mut result_demon = Fq::zero(); let _l_x = Fq::one(); let mut w = Vec::with_capacity(points.len()); for j in 0..points.len() { let x_j = points[j].0; w.push(Fq::one()); for (k, \u0026(x_k, _)) in points.iter().enumerate() { if j != k { let denom = x_j - x_k; w[j] *= Fq::one() / denom; } } } for (j, \u0026(x_j, y_j)) in points.iter().enumerate() { result += (w[j] * y_j) / -x_j; result_demon += w[j]/-x_j; } result /= result_demon; result } Implementation of Polynomials Given a polynomial of the form $c_nx^n + c_n-1x^n-1 + c_n-2x^n-2 + … + c_1x + c_0$ and a value of$ x$, find the value of polynomial for a given value of $x$. Here $c_n, c_n-1, ..$ are integers (may be negative) and $n$ is a positive integer.\nInput is in the form of an array say poly[] where poly[0] represents coefficient for $x_n$ and poly[1] represents coefficient for xn-1 and so on. so the code is below :\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 #[derive(PartialEq, Debug)] pub struct Polynomial\u003cFq: Field\u003e { coefficients: Vec\u003cFq\u003e, } impl\u003cFq: Field\u003e Polynomial\u003cFq\u003e { /// Generates a polynomial with random coefficients and a given intercept pub fn from_intercept(intercept: Fq, degree: usize) -\u003e Polynomial\u003cFq\u003e { let mut result = Vec::with_capacity(degree); let fq = Fq::gen_random(); for _ in 1..degree { result.push(fq); } result.push(intercept); Polynomial { coefficients: result } } /// Evaluates a Polynomial with coefficients in field Fq at a given x value pub fn evaluate_at(\u0026self, x: Fq) -\u003e Fq { self.coefficients .iter() .skip(1) .fold(*self.coefficients.first().unwrap(), |result, \u0026a_i| { a_i + (result * x) }) } } overview the algrithm again we have already get the concept of the required knowlege of the mathematical tools and the code of them .\nNow we begin try to code the step of the algrithm of Shamir’s Secret Sharing :\nRepresents a set of points which make up a share of a secret.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 pub struct Share\u003cFq: Field\u003e { points: Vec\u003c(Fq, Fq)\u003e, } /// A set of functions for Shamir Secret Sharing pub struct Shamir; impl Shamir { /// separate a secret (a byte slice) into n shares, of which only k are needed to recover the secret /// This requires 0 \u003c k \u003c= n \u003c 256 and supports arbitrary sized secrets /// We define a function that separare the secret into n shares ,secret is its length and its a u8 bytes slice . pub fn separate(secret: \u0026[u8], k: usize, n: usize) -\u003e Result\u003cVec\u003cShare\u003cGF256\u003e\u003e, \u0026'static str\u003e { // This block to make sure the the range of k and n is correct,because the definition of //Shamir secret is a secret which seprate into n shares ,and k of the n shares (k\u003cn)could recover // the secret and at the the same time we define this n shares size between 1 to 255. if n == 0 || n \u003e= 255 { return Err(\"n must be between 1 and 255\"); } else if k == 0 || k \u003e n { return Err(\"k must be between 1 and n\"); } // Here define the shares in a vector which have an empty heap but has n capacity.And the type //of the shares are Galois field 2^8. let mut shares: Vec\u003cShare\u003cGF256\u003e\u003e = Vec::with_capacity(n); //make every share contains the points which the amount of it is same as the secret length. for _ in 0..n { shares.push(Share { points: Vec::with_capacity(secret.len()), }); } // define a Hashset collection name point_set ，this point set help us to make sure the //random byte is not repeated. let mut point_set = std::collections::HashSet::new(); // this progress use the methods from_intercept in mod polynomial to gennerate the coeffients // of the Polynomial.and its a for loop to generate each points of every share in n shares. for \u0026secret_byte in secret { //we construct the polynomial that is k degree function which has a intercept made by the element of the secret. //this fuction return the coeffients and the intercept let polynomial: Polynomial\u003cGF256\u003e = Polynomial::from_intercept(GF256(secret_byte), k - 1); // to verify no random byte is repeated for share in shares.iter_mut() { // genarate byte randomly let mut random_byte = thread_rng().gen::\u003cu8\u003e(); //if point_set contains the random_byte already or it generate o,we should regenarate the random_byte while point_set.contains(\u0026random_byte) || random_byte.ct_eq(\u00260).into() { random_byte = thread_rng().gen::\u003cu8\u003e(); } //we insert the random_byte we had genarated into the point_set which is the type of hashset. point_set.insert(random_byte); //put the random_byte into struct GF256 to genarate the horizontal axis of the points. //because this is a for loop of shares ,so end of this loop,it will generate n x for the each poins of n shares first. let x = GF256(random_byte); // use the funcion evaluate to caculate the vertical axis of the points in the random genarate polymonimal let y = polynomial.evaluate_at(x); //push the points into the shares collection. //then they became the firt element of the share ,when the first time of the for loop ended it will // generate the first element of each of the n shares. share.points.push((x, y)); } //clear the point_set point_set.clear(); } //return the shares Ok(shares) } Combines a slice of shares to recover the secret which is returned as a vector of bytes.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 pub fn recover(shares: \u0026[Share\u003cGF256\u003e]) -\u003e Vec\u003cu8\u003e { // define the length of the generated points we will use to combine to. let secret_size = shares.first().unwrap().points.len(); //define the capacity of the result which is recoverd by the methods. let mut result = Vec::with_capacity(secret_size); //we map the shares and rebuild the construct such as // {Element0[\u003cpoint1\u003cx,y\u003e,point2\u003cx,y\u003e..pointn\u003cx,y\u003e]...Elementsize[\u003cpoint1\u003cx,y\u003e,point2\u003cx,y\u003e..pointn\u003cx,y\u003e]} for i in 0..secret_size { let points = shares .iter() .map(|share| share.points[i]) .collect::\u003cVec\u003c(GF256, GF256)\u003e\u003e(); //use the x value of these points and barycentric lagrange interpolation to recover the origin each bytes of the secret. let secret_byte = barycentric_interpolate(\u0026points); result.push(secret_byte.0); } //return the secret. result } } This is all the knowledge and steps of Shamir‘s secret sharing algrithm .Thank you for reading .\n","description":"","tags":null,"title":"Explain Shamir’s Secret Sharing algorithm Like I’m Eleven","uri":"/posts/shamir/"}]
